---
title: "Using plyranges and GenomicRanges to perform common genomic data wrangling tasks"
author: "Stuart Lee and Michael Lawrence"
date: "`r Sys.Date()`"
output:
  html_document::
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, 
  warning = FALSE,
  message = FALSE,
  fig.path = "./figures/"
)

# -- pacakges
library(dplyr)
library(GenomicRanges)
library(plyranges)
library(HelloRangesData)
```

# Introduction

This tutorial will show you how to think about and perform common genomic data 
wrangling tasks using the using the [plyranges]() and [GenomicRanges]() 
Bioconductor packages. These packages represent genomic data using the 
_GRanges_ data structure, which provides a powerful abstraction for working
with measurements or annotations along genomic regions. In this tutorial
you will use _GRanges_ object to construct workflows to

- read data from common formats like BED 
- find overlaps between different sets of genomic regions
- compute coverage and related summaries

## Who is this tutorial is for?

If you are an R beginner or new to the Bioconductor ecosystem, this tutorial
provides a comprehensive overview of one of the most important data structures
in Bioconductor, _GRanges_. We show you how to think of this data structure
as a special kind of table and perform all kinds of operations on it.

If you are familiar with the tidyverse suite of packages, then the operations
and workflows we will develop will look somewhat familiar to you. However, due 
to the complexity of genomics data, plyranges develops a new grammar based
on the tidyverse to meet the needs of the computational biologist. 

We assume you know what a data.frame is and have some knowledge
of vector types in R.

The examples and and exercises are based on the [HelloRanges package tutorial](http://bioconductor.org/packages/release/bioc/vignettes/HelloRanges/inst/doc/tutorial.pdf).
If you are familiar with bedtools, this is an excellent resource for learning
how similar operations are performed with Bioconductor packages.

## Setup 

You will need R (version 3.5 or greater) with the following packages installed:

```{r packages, eval = FALSE}
# CRAN
library(dplyr)
library(ggplot2)
# Bioconductor
library(GenomicRanges)
library(plyranges)
library(HelloRangesData)
```

If you do not have these packages you can install them as follows:

```{r packages-install, eval = FALSE}
install.packages("dplyr")
install.packages("ggplot2")
 # -> Bioconductor packages are installed with this package
install.packages("BiocManager")
# then use the install function from BiocManager 
BiocManager::install(c("GenomicRanges", "plyranges", "HelloRangesData"))
```


# Introducing GRanges

The GRanges is a fundamental data structure used in the Bioconductor ecosystem. 
It is very similar to the base R data.frame but with appropriate
semantics for a genomics experiment: it has fixed columns
for the chromosome, start and end coordinates, and the strand, along
with an arbitrary set of additional columns, consisting of
measurements or metadata specific to the data type or experiment.

```{r GRanges, echo = FALSE, fig.cap="An illustration of a GRanges data object for a single sample from an RNA-seq experiment. The core components of the object include a seqnames column (representing the chromosome), a ranges column which consists of start and end coordinates for a genomic region, and a strand identifier (either positive, negative, or unstranded). Metadata are included as columns to the right of the dotted line as annotations (gene-id) or range level covariates (score).", out.width="\\textwidth"}
knitr::include_graphics("./Lee_Plyranges/GRanges.png")
```


GRanges balances flexibility with formal
constraints, so that it is applicable to virtually any genomic
workflow, while also being semantically rich enough to support
high-level operations on genomic ranges.

We can create a GRanges from an ordinary data.frame with plyranges using
the `as_granges` function:

```{r}
library(plyranges, quietly = TRUE)
genes <- data.frame(seqnames = "VI", 
                    start = c(3322, 3030, 1437,  5066, 6426, 836),
                    end = c(3846, 3338, 2615, 5521, 7565, 1363),
                    strand = c("-", "-", "-", "+", "+", "+"),
                    gene_id=c("YFL064C", "YFL065C", "YFL066C", 
                              "YFL063W", "YFL062W", "YFL067W"),
                    gc = runif(6),
                    score = rbinom(6, size = 3, p = 0.1),
                    stringsAsFactors = FALSE)
genes <- as_granges(genes)

genes
```

You might notice a few  differences between how the `genes` GRanges
object is printed compared to an ordinary data.frame or tibble.  

The measurements/annotation columns like gene_id, gc and score are placed
on the right hand side of the "|". These are referred to as metadata columns;
they are not strictly required to construct a GRanges object but are useful
for providing biological context.

The required part of a GRanges object are left of the "|" 
character. These are the seqnames column, the ranges (start, end, width) column,
and the strand column. 

You may have also noticed that underneath each column name is the type of
that column. The metadata columnns are of some usual base R types like 
`character`, `numeric`, and `integer` but the core columns may be
unfamilar. The seqnames and strand column are (factor) `Rle` columns.
`Rle` stands for run length encoding, and refers to how a column is stored.
For now, there is no harm in thinking about these as ordinary factors.

The ranges column is an `IRanges` which really consists 
of three columns: the start, end and width coordinates of the range. 
This becomes apparent if you look back to our original data.frame - the start
and end columns from there are just the start and end intervals of the ranges 
column. 

Do not be concerned if this a bit confusing for now, once we start
playing with our GRanges object, everything will become clearer.


# GRanges transformation and import

Once you have obtained data from an experiement or a public repository,
you often want to compute summaries, create new columns, modify the
genomic regions or just rearrange the data. Here you will learn how 
to achieve these tasks using the plyranges:

* Modify, subset, and aggregate genomic data with the `mutate()`, 
`filter()`, and `summarise()`.
* Modify genomic regions with the `mutate()`...
* And  while fixing the start/end/center coordinates with the `anchor_*` family
of functions.
* Sort genomic ranges with `arrange()`.
* Merge all overlapping and adjacent genomic regions with `reduce_ranges()`.
* Merge the end points of all genomic regions with `disjoin_ranges()`.

Any of the above operations can be performed on subsets of the
data with `group_by()`.

## Getting started

To begin we will test out some of these operations using a 
GRanges object obtained from a BED file
containing annotated exons from RefSeq from the hg19 genome build. 
To load the file as GRanges we can simply use the `read_bed` function from
plyranges.

```{r load-bed}
exons_bed <- system.file("extdata", "exons.bed", package="HelloRangesData")

# our genome build
build <- genome_info("hg19")

build

exons <- read_bed(exons_bed, 
                  genome_info = build)
exons
```

The `genome_info()` function automatically propagates the reference
annotations from the hg19 reference as a GRanges. This is important for
ensuring the integrity of any operations involving modifications to 
genomic regions, like overlaps or nearest neighbours. 

## Filter ranges with `filter()`

We can `filter()` ranges based on column values being `TRUE`. This
requries passing the ranges, along with one or more logical expressions.

For example, we can restrict exons to those that are on the
the X chromosome:

```{r filter-01}
filter(exons, seqnames == "chrX")
```

Multiple conditions can be composed together within a call to filter by 
seperating the expressions with a comma. To restrict exons to those 
that are on the X chromosome *AND* on the positive strand:

```{r filter-02}
filter(exons, seqnames == "chrX", strand == "+")
```

This is equivalent to
```{r filter-03}
filter(exons, seqnames == "chrX" & strand == "+")
```

But not the same as filtering exons to those on the X chromosome or 
positively stranded

```{r filter-04}
filter(exons, seqnames == "chrX" | strand == "+")
```

For a comprehensive overview of all R's logical operators see [__section
5.2.2 of R for Data Science__](https://r4ds.had.co.nz/transform.html#filter-rows-with-filter).

### Overlap based filtering

We can also restrict ranges by overlaps using  `filter_by_overlaps()`, 
or exclude non overlapping features using `filter_by_non_overlaps()`.

To see how these work it'll be useful to load another GRanges object, 
this time from a BED file containing CpG islands.

```{r cpg}
cpg_bed <- system.file("extdata", "cpg.bed", package = "HelloRangesData")

cpg <- read_bed(cpg_bed, 
                genome_info = build)
cpg
```

To find exons that do not overlap any cpg islands we 
```{r filter-06}
filter_by_non_overlaps(exons, cpg)
```

Or we could find the cpg islands that are overlapped by exons 

```{r filter-07}
filter_by_overlaps(cpg, exons)
```

## Modify metadata with `mutate()`

New metadata columns can be created using the `mutate()` function. The first
argument is the GRanges object we are mutating and the remaining arguments
are name-value pairs, where name refers to name of the new column being 
created and value refers to the value the new column will take.

As an example, we make a new column called total_length which contains the number
of bases of in each CpG island. This is just a copy of the width column in 
Ranges object.
```{r mutate-01}
mutate(cpg, total_length =  width)
```

Multiple columns can be computed inside of a call to `mutate()` by seperating
each pair of name-value expressions with a comma, we could add an additional
column called mid, which is the midpoint of the CpG island. 

```{r mutate-02}
mutate(cpg,
       total_length = width,
       mid = start + (width - 1) %/% 2
       )
```

Moreover, `mutate()` keeps track of which columnns have been created, so
you can create new columns using pre-existing ones. 

```{r mutate-03}
mutate(cpg,
       total_length = width,
       mid = start + (width - 1) %/% 2,
       mid2 = sqrt(mid)
       )
```


In plyranges and GenomicRanges there are additional helpers that are useful
for column creation during data analysis. As an example, we can 
add the count of the number of times each cpg island overlaps an exon and
add a logical column asking if a cpg island is contained entirely within an 
exon.

```{r}
cpg2 <- mutate(cpg, 
               n_olap = count_overlaps(cpg, exons),
               is_contained = cpg %within% exons
               )

cpg2
```


## Composing workflows with the pipe `%>%`

Now that you can use `filter()` and `mutate()`, you might like to start 
thinking about how you can combine them to form workflows. One way we can do
this is with the pipe operator, `%>%`. 

The pipe operator is read as the word _then_:

```{r pipe-01}
# take cpg then filter
cpg %>% 
  filter(seqnames == "chrX")
```

The argument on the left hand side of the pipe is forwarded to the first
argument of the function on the right hand side. This can be made explicit
with a `.` 

```{r pipe-02}
cpg %>% 
  filter(., seqnames == "chrX")
```

As long as the the result of applying the pipe returns a GRanges object,
multiple functions can be strung together:

```{r pipe-03}
cpg %>% 
  filter(seqnames == "chrX") %>% 
  filter(strand == "+") %>% 
  mutate(new_col = runif(n())) 
```


The use of the `.` can also make pipelines more succinct, as the argument
on the left hand side can be forwarded to multiple parts of the function
on the right hand side. We can rewrite, the creation of cpg2 above more
compactly as

```{r}
cpg %>%  
  mutate(n_olap = count_overlaps(., exons),
         is_contained = . %within% exons)
```

## Modifying genomic regions with `mutate()` 

We have learnt in the above sections how to add new metadata columns with
`mutate()` but we can also use `mutate() to modify the genomic regions.
Recall that there are three components that make up a genomic region; the
start, end, and the width. 

Let's go back to our original GRanges of yeast genes. What happens
if we add 10 bases to the width? 

```{r anchor-01}
genes

genes %>% 
  mutate(width = width + 10L)
```

All three components are mutally dependent, so in order to preserve the 
integrity of the GRanges structure, either the start or the end positions 
must change. In the case of adding to the width position by default 
the start is fixed and the end is increased. But what if we would like
to modify the width but leave the end of fixed? Or the midpoint fixed? 

The solution is to anchor those positions (i.e. leave them fixed), 
using the `anchor_*()` family of functions:
```{r anchor-02}
# fix the end
genes %>% 
  anchor_end() %>% 
  mutate(width = width + 10L)

# fix the centre
genes %>% 
  anchor_centre() %>% 
  mutate(width = width + 10L)
```

There are additional anchors that account for the strandedness of features,
we can fix the 3' or 5' parts of a GRanges object using `anchor_3p()` 
or `anchor_5p()`, respectively.

## Summarise annoations and measurements with `summarise()`

We can compute summarise columns GRanges object using `summarise()`. Using
`summarise()` is very similiar to `mutate()`, we construct new columns
that are summaries of the columns in the input the GRanges. 

```{r}
exons %>% 
  summarise(
    count = n(),
    median_width = median(width)
  )
```

The main difference is that by summarising our data, we lose the necessary
information required to form a valid GRanges. Instead, `summarise()` returns
a `DataFrame` (see `S4Vectors::DataFrame()` for more information). The 
`DataFrame` is the Bioconductor version of the base R data.frame. It works
mostly the same way as the base R `data.frame` but can also hold data structures
that are common in Bioconductor (like `Rle` mentioned above).

## Summarise over the genome with `reduce_ranges()` and `disjoin_ranges()`

To preserve the GRanges data structure while performing summaries, it
is often useful to either merge overlapping ranges (called reducing) or expand
ranges by finding the union of the end points or ranges (called disjoining).

To make this more concrete let's `reduce_ranges()` and `disjoin_ranges()` 
on the `genes` object we defined above. 

```{r reduce-01}
# to make things easier to compare 
# sort by the start and end coordinates
genes %>% 
  arrange(start, end)

# reduce_ranges will merge the 3rd and 4th ranges above
genes %>% 
  reduce_ranges()

# disjoin ranges will split the 3rd and 4th ranges into
# 3 disjoint ranges. 
genes %>% 
  disjoin_ranges()
```

Note that by default, `reduce_ranges()` and `disjoin_ranges()` will discard
any strand information. To preserve them use `reduce_ranges_directed()` and
`disjoin_ranges_directed()`.

The `reduce_ranges()` and `disjoin_ranges()` can perform summarisation too.
For example, we can reduce exons and count the number of exons
that were merged together, and retain the name of the exons that were merged.

```{r reduce-03}
exons %>% 
  reduce_ranges(
    count = n(),
    name = paste(name, collapse = ",")
  )
```


## Analyses over groups with `group_by()`


## Finding overlaps with the join operator

```{r}
intersect_rng <- join_overlap_intersect(cpg, exons)
intersect_rng
```

## Summarising coverage with `compute_coverage()`

Often we are interested in counting the number of features over
the genome that overlap each other. In `plyranges` this is
done with the `compute_coverage()` function in combination with other functions
to manipulate the results. This function will always return a new GRanges 
with a column called score which contains the coverage value over a range. 

### Coverage values

By default, `compute_coverage()` returns all coverage scores even if there is
no coverage over a genomic region.
```{r cv-1}
cvg <- exons %>% 
  compute_coverage()

cvg

cvg %>% filter(score > 0)
```

Also note that computing coverage will result in a GRanges that is disjoint,
which you can check with `isDisjoint()` from GenomicRanges. 

### Coverage histogram

We can `summarise()` the coverage scores as a histogram over all chromosomes 
in a genome using `group_by()`.

We count the total number of bases (that is, the width of the range) over
each chromosome over each coverage score. 

```{r cv-hist0}
cvg_hist <- cvg %>%
  group_by(seqnames, score) %>% 
  summarise(count = sum(width))
```

We can also compute the coverage histogram over the entire genome by grouping
over the scores. Note that we coerce the width to a numeric
to avoid integer overflow, when summing.

```{r}
cvg_hist_all <- cvg %>% 
  mutate(total_length = as.numeric(width)) %>% 
  group_by(score) %>% 
  summarise(
    seqnames = "genome", 
    count = sum(total_length)
  )
```

Then the results can be put togeher using `rbind`. 

### A more complicated example

Here we perform another example where we find exons with no coverage that
overlap cpg islands. To compose a chain first we compute the coverage
then use a filter to restrict to zero coverage ranges. Then we
perfrom an inner overlap join to find which cpg islands overlap the exonic
regions with zero coverage.

```{r}
overlaps <- exons %>% 
  compute_coverage() %>% 
  filter(score == 0L) %>% 
  join_overlap_inner(.,  cpg) 

overlaps
```

We can also compute the coverage histogram of exons over cpg islands
and then plot results as an ecdf.

```{r}
cvg_over_exons <- exons %>% 
  compute_coverage() %>%
  join_overlap_inner(., cpg) %>%
  mutate(
    total_length = as.numeric(width),
    genome_length = sum(total_length)
  ) %>% 
  group_by(score, genome_length) %>%
  summarise(
    count = sum(total_length),
    fraction = sum(total_length) / unique(genome_length)
  ) 

cvg_over_exons

plot(1 - cumsum(fraction) ~ score, 
     data = cvg_over_exons, 
     xlim = c(0,30), 
     type= "s", 
     xlab = "coverage", 
     ylab = "fraction of bp > coverage")
```


# Learning more

We have touched the surface of what's possible with plyranges and
GenomicRanges. A good starting point to learn more about GenomicRanges
is [here](https://bioconductor.github.io/BiocWorkshops/solving-common-bioinformatic-challenges-using-genomicranges.html) and plyranges is [here](https://bioconductor.github.io/BiocWorkshops/fluent-genomic-data-analysis-with-plyranges.html). 

If you have any questions about the use of these packages, please ask
a question on [support.bioconductor.org](https://support.bioconductor.org/) 
or post an issue on [github](https://github.com/sa-lee/plyranges).





